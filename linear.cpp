#include <LiquidCrystal.h>
#include "Bounce2.h"
#include "linear.h"
#include "sensing.h"
#include "chars.h"

//Macros
#define BLANK(num) ({unsigned int i;for(i=0; i<num; i++){lcd->print(" ");}})

//Private prototypes
//differently from vanilla Arduino projects, those are needed, as the makefile
//used does not auto-generate the prototypes (thank god)
//also, the setup() and loop() functions *does not* need to be prototyped
void pinSetup();
void lcdSetup();
void updateReadings(Stats *stats); //update readings on screen
void bias(boolean run); //enable/disable amplification bias
void warning(boolean run); //enable/disable warning on screen and bias cutoff
void lock(boolean run); //enable/disable bias lock
void changeBand(); //change to the next band in the cycle

//LCD readings and positions, considering 20x4 screen
#define TX_POSX 0
#define TX_POSY 3
#define RX_POSX 0
#define RX_POSY 3
#define WARNING_POSX  12
#define WARNING_POSY  2
#define LOCKED_POSX 19
#define LOCKED_POSY 2
#define BAND_POSX 6
#define BAND_POSY 0
#define TEMP_POSX 16
#define TEMP_POSY 0
#define BANDSNUM 4 //number of different bands
#define BANDSIZE 7 //how many chars the largest band msg occupies
const char *txMsg = "TX=";
const char *rxMsg = "RX";
const char *warningMsg = "ATENCAO";
const char *bandMsg[4] = {
  "80m",
  "40m",
  "20m/15m",
  "12m/10m"
};

//Globals
LiquidCrystal *lcd;
boolean locked=false;
Stats stats;
Bounce bandsw=Bounce();
char currentBand=0;
State lastState=RX;
Warn lastWarn=OK;

//Arduino framework functions
//main() is auto-generated by the makefile and calls setup() once and loop()
//repeteadly, just as vanilla Arduino projects
void setup() {
  pinSetup();
  lcdSetup();
  return;
}

void loop() {
  readSensors(&stats);
  if(statsOk(&stats)){
    warning(false);
    if(!locked && digitalRead(YTX_PIN))
      bias(true);
    else
      bias(false);
  }else{
    warning(true);
    lock(true);;
  }

  if(locked)
    lock(digitalRead(REARM_PIN));

  updateReadings(&stats);

  bandsw.update();
  if(bandsw.fell())
    changeBand();
  return;
}

void pinSetup(){
  pinMode(RELAY80_PIN, OUTPUT);
  pinMode(RELAY40_PIN, OUTPUT);
  pinMode(RELAY20_PIN, OUTPUT);
  pinMode(RELAY10_PIN, OUTPUT);
  pinMode(BIAS_PIN, OUTPUT);
  bandsw.attach(BANDSW_PIN, INPUT_PULLUP);
  bandsw.interval(DEBOUNCETIME);
  pinMode(REARM_PIN, INPUT_PULLUP);
  pinMode(YD0_PIN, INPUT);
  pinMode(YD1_PIN, INPUT);
  pinMode(YD2_PIN, INPUT);
  pinMode(YD3_PIN, INPUT);
  return;
}

void lcdSetup(){
  int i;

  lcd = new LiquidCrystal(LCDR_PIN, LCDE_PIN, LCD4_PIN, LCD5_PIN, LCD6_PIN, LCD7_PIN);
  lcd->begin(ROWS, COLUMNS); //AGM-2004D-201 has 20 rows and 4 lines

  //black 1 to 4 aren't contained into LCD default charset, so we need to map
  for(i=0;i<=3;i++)
    lcd->createChar(char_black[i+1], map_black[i]);
  lcd->createChar(char_key, map_key); //key symbol

  lcd->setCursor(0, 0);
  lcd->print("BANDA=        T=  ");
  lcd->write(char_degree);
  lcd->print("C");
  lcd->setCursor(0,1);
  lcd->print("POT.E=   W  ROE= .");
  lcd->setCursor(0, 2);
  lcd->print("POT.S=   W");
  lcd->setCursor(RX_POSX, RX_POSY);
  lcd->print(rxMsg);
  lcd->setCursor(BAND_POSX, BAND_POSY);
  lcd->print(bandMsg[0]);

  //Interface demo
  /*
  lcd->setCursor(6, 0);
  lcd->print("12m/10m");
  lcd->setCursor(16, 0);
  lcd->print("99");
  lcd->setCursor(6, 1);
  lcd->print(" 90");
  lcd->setCursor(16, 1);
  lcd->print("1.50");
  lcd->setCursor(6, 2);
  lcd->print("990");
  lcd->setCursor(WARNING_POSX, WARNING_POSY);
  lcd->print(WARNING_MSG);
  lcd->write(char_key);
  lcd->setCursor(0, 3);
  lcd->print("TX=");
  for(i=0;i<=5;i++)
    lcd->write(char_black[5]);
  lcd->write(char_black[3]);
  */
  return;
}

void changeBand(){
  currentBand<BANDSNUM-1 ? currentBand++ : currentBand=0;
  lcd->setCursor(BAND_POSX, BAND_POSY);
  BLANK(BANDSIZE); //largest band name
  lcd->setCursor(BAND_POSX, BAND_POSY);
  lcd->print(bandMsg[int(currentBand)]);
}

void bias(boolean run){
  if(run){
    if(lastState==RX){
      digitalWrite(BIAS_PIN, HIGH);
      lcd->setCursor(TX_POSX, TX_POSY);
      lcd->print(txMsg);
      lastState=TX;
    }
  }else{
    if(lastState==TX){
      digitalWrite(BIAS_PIN, LOW);
      lcd->setCursor(TX_POSX, TX_POSY);
      BLANK(COLUMNS); //blank whole line, since there could be a bargraph
      lastState=RX;
      lcd->setCursor(RX_POSX, RX_POSY);
      lcd->print(rxMsg);
    }
  }
  return;
}

void warning(boolean run){
  if(run){
    if(lastWarn==OK){
      bias(false);
      lcd->setCursor(WARNING_POSX, WARNING_POSY);
      lcd->print(warningMsg);
      lastWarn=WARN;
    }
  }else{
    if(lastWarn==WARN){
      lcd->setCursor(WARNING_POSX, WARNING_POSY);
      BLANK(strlen(warningMsg));
      lastWarn=OK;
    }
  }
  return;
}

void lock(boolean run){
  if(run){
    if(!locked){
      lcd->setCursor(LOCKED_POSX, LOCKED_POSY);
      lcd->write(char_key);
      locked=true;
    }
  } else {
    if(locked){
      lcd->setCursor(LOCKED_POSX, LOCKED_POSY);
      BLANK(1);
      locked=false;
    }
  }
}

void updateReadings(Stats *stats){
  lcd->setCursor(TEMP_POSX, TEMP_POSY);
  if(stats->temp > MAXTEMPREAD) //we only have space for 2 digits
    lcd->print("!!");
  else {
    if (stats->temp <= 9) //liquidcrystal print doesn't support formatting
      lcd->print("0");
    lcd->print(stats->temp);
  }
  return;
}
